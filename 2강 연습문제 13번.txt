case 1번과 case 2번의 차이는 함수의 구현 내용을 어디에 작성하느냐에 따라 다릅니다.

case 1번은 함수의 구현 내용을 main.cpp 파일 내부에 직접 작성한 방법입니다. 이 방법의 장점은 함수의 구현 내용이 한 번에 파악하기 쉽다는 것입니다. 하지만 함수를 다른 파일에서도 사용하고자 할 때, 함수의 구현 내용을 모든 파일에 일일이 복사해 넣어야 합니다. 이는 코드의 중복을 유발하고, 유지보수를 어렵게 만듭니다.

반면, case 2번은 함수의 구현 내용을 sub.cpp 파일 내부에 작성하고, main.cpp 파일에서는 헤더 파일인 sub.h를 include하여 함수의 선언만 사용하는 방법입니다. 이 방법의 장점은 함수의 구현 내용을 다른 파일에서도 사용할 수 있다는 것입니다. 따라서 코드의 재사용성을 높일 수 있습니다. 또한, 함수의 구현 내용이 변경되었을 때에도, sub.cpp 파일만 수정하면 되므로 유지보수가 용이합니다.

따라서, case 2번이 더 효율적이며, 좋은 코드의 작성 방법입니다. 함수의 구현 내용을 분리하여 다른 파일에서도 사용할 수 있도록 만드는 것은 코드의 재사용성을 높여줍니다. 이는 코드의 중복을 방지하고, 유지보수를 쉽게 만들어주는 등 많은 이점을 가져다 줍니다.

case 1에서는 헤더 파일에 함수의 선언과 정의를 모두 넣고, main.cpp에서는 헤더 파일을 include하여 함수를 사용하는 방법입니다.

따라서 case 1과 case 2의 차이는 함수의 구현 내용을 어디에 작성하느냐에 따라 다릅니다. case 1에서는 함수의 구현 내용이 헤더 파일에 모두 포함되어 있으므로, 다른 파일에서도 사용할 수 있습니다. 하지만 이는 함수를 사용하는 모든 파일에서 함수의 구현 내용이 중복되어 포함되므로, 코드의 크기가 커지고 중복된 코드가 발생할 수 있습니다.

case 2에서는 함수의 구현 내용을 sub.cpp 파일 내부에 작성하고, main.cpp 파일에서는 헤더 파일인 sub.h를 include하여 함수의 선언만 사용하는 방법입니다. 이 방법은 함수를 사용하는 모든 파일에서 함수의 구현 내용이 중복되지 않으므로, 코드의 크기를 줄이고 중복된 코드를 방지할 수 있습니다.

따라서, case 2가 더 효율적이며, 좋은 코드의 작성 방법입니다. 함수의 구현 내용을 분리하여 다른 파일에서도 사용할 수 있도록 만드는 것은 코드의 재사용성을 높여줍니다. 이는 코드의 중복을 방지하고, 유지보수를 쉽게 만들어주는 등 많은 이점을 가져다 줍니다.
